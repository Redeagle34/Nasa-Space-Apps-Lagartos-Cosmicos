<!DOCTYPE html>
<html lang="es">
<head>
    <script type="importmap">
    {
        "imports": {
            "three": "/build/three.webgpu.js",
            "three/webgpu": "../build/three.webgpu.js",
            "three/tsl": "/build/three.tsl.js",
            "three/addons/": "./jsm/"
        }
    }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pronóstico Futurista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Evita barras de scroll por el canvas */
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Coloca el canvas detrás del contenido */
        }
        /* Estilo para el placeholder del input */
        input::placeholder {
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Contenedor para la escena 3D de Three.js -->
    <canvas id="bg-canvas"></canvas>

    <!-- Contenedor principal de la UI -->
    <main class="relative z-10 flex flex-col items-center justify-center h-screen p-4 transition-opacity duration-1000" id="main-ui">
        <div class="text-center w-full max-w-2xl">
            <h1 class="text-4xl md:text-6xl font-bold mb-6 text-shadow-lg">Cuéntame, ¿cuál es tu plan?</h1>
            <p class="text-lg md:text-xl text-gray-300 mb-8">Escribe un lugar y una fecha futura (ej. "París en 3 meses") para obtener un pronóstico especulativo.</p>
            
            <form id="location-form" class="flex flex-col sm:flex-row gap-3">
                <input type="text" id="location-input" placeholder="Ej: Tokio en 6 meses..." class="w-full px-5 py-4 text-lg bg-gray-800 bg-opacity-70 border border-gray-600 rounded-full focus:ring-2 focus:ring-blue-500 focus:outline-none placeholder-gray-500 transition-all duration-300">
                <button type="submit" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-lg font-semibold transition-all duration-300">
                    Visualizar
                </button>
            </form>
        </div>
    </main>
    
    <!-- Contenedor para mostrar los resultados del pronóstico -->
    <div id="forecast-result" class="hidden absolute z-20 top-0 left-0 w-full h-full flex items-center justify-center p-4 bg-black bg-opacity-50 backdrop-blur-sm">
        <div class="bg-gray-800 bg-opacity-80 p-8 rounded-2xl shadow-2xl max-w-md w-full border border-gray-700">
            <h2 class="text-3xl font-bold mb-2" id="forecast-location"></h2>
            <p class="text-lg text-blue-300 mb-6" id="forecast-date"></p>
            <div id="forecast-details">
                <!-- El contenido del pronóstico se insertará aquí -->
            </div>
             <p class="text-sm text-gray-400 mt-6 italic">Nota: Este es un pronóstico simulado con fines demostrativos.</p>
            <button id="back-button" class="w-full mt-6 px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-lg font-semibold transition-colors">Volver</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { step, normalWorldGeometry, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';

        // --- Declaración de variables globales ---
        let camera, scene, renderer, globe, clock;

        // --- Variables de la UI que conservamos ---
        let targetPosition = new THREE.Vector3(0, 0, 5); // Posición inicial ajustada para el nuevo globo
        let forecastRequest = null;

        // --- Lógica principal ---
        init();

        function init() {
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 5); // Posición inicial más cercana

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);

            // Sol (Luz direccional)
            const sun = new THREE.DirectionalLight('#ffffff', 2.5);
            sun.position.set(0, 0, 3);
            scene.add(sun);

            // Texturas
            const textureLoader = new THREE.TextureLoader();
            const dayTexture = textureLoader.load('./textures/planets/earth_day_4096.jpg');
            dayTexture.colorSpace = THREE.SRGBColorSpace;
            dayTexture.anisotropy = 8;

            const nightTexture = textureLoader.load('./textures/planets/earth_night_4096.jpg');
            nightTexture.colorSpace = THREE.SRGBColorSpace;
            nightTexture.anisotropy = 8;

            const bumpRoughnessCloudsTexture = textureLoader.load('./textures/planets/earth_bump_roughness_clouds_4096.jpg');
            bumpRoughnessCloudsTexture.anisotropy = 8;

            // --- Creación del Globo Terráqueo (Lógica de Shaders de WebGPU) ---
            const sphereGeometry = new THREE.SphereGeometry(1, 64, 64); // Radio de 1

            // Material del globo
            const globeMaterial = new THREE.MeshStandardNodeMaterial();
            const cloudsStrength = texture(bumpRoughnessCloudsTexture, uv()).b.smoothstep(0.2, 1);
            globeMaterial.colorNode = mix(texture(dayTexture), vec3(1), cloudsStrength.mul(2));
            const roughness = max(texture(bumpRoughnessCloudsTexture).g, step(0.01, cloudsStrength));
            globeMaterial.roughnessNode = roughness.remap(0, 1, uniform(0.25), uniform(0.35));

            const night = texture(nightTexture);
            const sunOrientation = normalWorldGeometry.dot(normalize(sun.position)).toVar();
            const dayStrength = sunOrientation.smoothstep(-0.25, 0.5);

            const viewDirection = positionWorld.sub(cameraPosition).normalize();
            const fresnel = viewDirection.dot(normalWorldGeometry).abs().oneMinus().toVar();

            const atmosphereDayColor = uniform(color('#4db2ff'));
            const atmosphereTwilightColor = uniform(color('#bc490b'));
            const atmosphereColor = mix(atmosphereTwilightColor, atmosphereDayColor, sunOrientation.smoothstep(-0.25, 0.75));

            const atmosphereDayStrength = sunOrientation.smoothstep(-0.5, 1);
            const atmosphereMix = atmosphereDayStrength.mul(fresnel.pow(2)).clamp(0, 1);

            let finalOutput = mix(night.rgb, globeMaterial.colorNode, dayStrength);
            finalOutput = mix(finalOutput, atmosphereColor, atmosphereMix);
            globeMaterial.outputNode = vec4(finalOutput, output.a);

            const bumpElevation = max(texture(bumpRoughnessCloudsTexture).r, cloudsStrength);
            globeMaterial.normalNode = bumpMap(bumpElevation);

            globe = new THREE.Mesh(sphereGeometry, globeMaterial);
            scene.add(globe);

            // Material de la atmósfera
            const atmosphereMaterial = new THREE.MeshBasicNodeMaterial({ side: THREE.BackSide, transparent: true });
            let alpha = fresnel.remap(0.73, 1, 1, 0).pow(3);
            alpha = alpha.mul(sunOrientation.smoothstep(-0.5, 1));
            atmosphereMaterial.outputNode = vec4(atmosphereColor, alpha);

            const atmosphere = new THREE.Mesh(sphereGeometry, atmosphereMaterial);
            atmosphere.scale.setScalar(1.04);
            scene.add(atmosphere);

            // Renderer
            renderer = new THREE.WebGPURenderer({
                canvas: document.querySelector('#bg-canvas'), // Usamos tu canvas existente
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate); // Usamos el bucle de animación del renderer
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // El bucle de animación. Por ahora, solo renderiza la escena.
        function animate() {
            renderer.render(scene, camera);
        }

        // --- Lógica de la Interfaz (aún no la conectamos) ---
        // (Dejaremos este espacio para pegar tu lógica de UI en el siguiente paso)

        // --- Manejo del redimensionamiento de la ventana ---
        window.addEventListener('resize', onWindowResize);
    </script>
</body>
</html>

