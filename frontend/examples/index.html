<!DOCTYPE html>
<html lang="es">
<head>
    <script type="importmap">
    {
        "imports": {
            "three": "../build/three.webgpu.js",
            "three/webgpu": "../build/three.webgpu.js",
            "three/tsl": "../build/three.tsl.js",
            "three/addons/": "./jsm/"
        }
    }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pronóstico Futurista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        input::placeholder {
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-black text-white">

<canvas id="bg-canvas"></canvas>

<main class="relative z-10 flex flex-col items-center justify-center h-screen p-4" id="main-ui">
    <div class="text-center w-full max-w-2xl">
        <h1 class="text-4xl md:text-6xl font-bold mb-6">Cuéntame, ¿cuál es tu plan?</h1>
        <p class="text-lg md:text-xl text-gray-300 mb-8">Escribe un lugar y una fecha futura (ej. "París en 3 meses").</p>
        
        <form id="location-form" class="flex flex-col sm:flex-row gap-3">
            <input type="text" id="location-input" placeholder="Ej: Tokio en 6 meses..." class="w-full px-5 py-4 text-lg bg-gray-800 bg-opacity-70 border border-gray-600 rounded-full focus:ring-2 focus:ring-blue-500 focus:outline-none placeholder-gray-500 transition-all duration-300">
            <button type="submit" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-lg font-semibold transition-all duration-300">
                Visualizar
            </button>
        </form>
    </div>
</main>

<div id="forecast-result" class="hidden absolute z-20 top-0 left-0 w-full h-full flex items-center justify-center p-4 bg-black bg-opacity-50 backdrop-blur-sm">
    <div class="bg-gray-800 bg-opacity-80 p-8 rounded-2xl shadow-2xl max-w-md w-full border border-gray-700">
        <h2 class="text-3xl font-bold mb-2" id="forecast-location"></h2>
        <p class="text-lg text-blue-300 mb-6" id="forecast-date"></p>
        <div id="forecast-details"></div>
        <p class="text-sm text-gray-400 mt-6 italic">Nota: Este es un pronóstico simulado.</p>
        <button id="back-button" class="w-full mt-6 px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-lg font-semibold">Volver</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { step, normalWorldGeometry, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';

let camera, scene, renderer, globe, clock, starLayers;
let targetPosition = new THREE.Vector3(0, 0, 5);
let forecastRequest = null;

init();

function init() {
    clock = new THREE.Clock();
    camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 0, 5);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const sun = new THREE.DirectionalLight('#ffffff', 2.5);
    sun.position.set(3, 0, 3);
    scene.add(sun);

    const textureLoader = new THREE.TextureLoader();
    const dayTexture = textureLoader.load('./textures/planets/earth_day_4096.jpg');
    dayTexture.colorSpace = THREE.SRGBColorSpace;
    const nightTexture = textureLoader.load('./textures/planets/earth_night_4096.jpg');
    nightTexture.colorSpace = THREE.SRGBColorSpace;
    const bumpRoughnessCloudsTexture = textureLoader.load('./textures/planets/earth_bump_roughness_clouds_4096.jpg');

    // --- Globo ---
    const sphereGeometry = new THREE.SphereGeometry(1, 64, 64);
    const globeMaterial = new THREE.MeshStandardNodeMaterial();
    const cloudsStrength = texture(bumpRoughnessCloudsTexture, uv()).b.smoothstep(0.2, 1);
    globeMaterial.colorNode = mix(texture(dayTexture), vec3(1), cloudsStrength.mul(2));
    const roughness = max(texture(bumpRoughnessCloudsTexture).g, step(0.01, cloudsStrength));
    globeMaterial.roughnessNode = roughness.remap(0, 1, uniform(1), uniform(0.2));
    const night = texture(nightTexture);
    const sunOrientation = normalWorldGeometry.dot(normalize(sun.position)).toVar();
    const dayStrength = sunOrientation.smoothstep(-0.25, 0.5);
    const viewDirection = positionWorld.sub(cameraPosition).normalize();
    const fresnel = viewDirection.dot(normalWorldGeometry).abs().oneMinus().toVar();
    const atmosphereDayColor = uniform(color('#4479a2'));
    const atmosphereTwilightColor = uniform(color('#000000'));
    const atmosphereColor = mix(atmosphereTwilightColor, atmosphereDayColor, sunOrientation.smoothstep(-0.25, 0.75));
    const atmosphereDayStrength = sunOrientation.smoothstep(-0.5, 1);
    const atmosphereMix = atmosphereDayStrength.mul(fresnel.pow(2)).clamp(0, 1);
    let finalOutput = mix(night.rgb, globeMaterial.colorNode, dayStrength);
    finalOutput = mix(finalOutput, atmosphereColor, atmosphereMix);
    globeMaterial.outputNode = vec4(finalOutput, output.a);
    const bumpElevation = max(texture(bumpRoughnessCloudsTexture).r, cloudsStrength);
    globeMaterial.normalNode = bumpMap(bumpElevation);
    globe = new THREE.Mesh(sphereGeometry, globeMaterial);
    scene.add(globe);

    // Atmósfera
    const atmosphereMaterial = new THREE.MeshBasicNodeMaterial({ side: THREE.BackSide, transparent: true });
    let alpha = fresnel.remap(0.73, 1, 1, 0).pow(3);
    alpha = alpha.mul(sunOrientation.smoothstep(-0.5, 1));
    atmosphereMaterial.outputNode = vec4(atmosphereColor, alpha);
    const atmosphere = new THREE.Mesh(sphereGeometry, atmosphereMaterial);
    atmosphere.scale.setScalar(1.04);
    scene.add(atmosphere);

    // --- Estrellas ultrarrealistas ---
    function createStarField(count, radius, minSize, maxSize, speedRange) {
        const positions = new Float32Array(count * 3);
        const baseOpacities = new Float32Array(count);
        for (let i = 0; i < count; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = radius * (0.8 + Math.random() * 0.2);
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);
            baseOpacities[i] = 0.5 + Math.random() * 0.5; // brillo base aleatorio
        }
        const starsGeo = new THREE.BufferGeometry();
        starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const starsMat = new THREE.PointsMaterial({
            size: 1,
            color: 0xffffff,
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const points = new THREE.Points(starsGeo, starsMat);
        points.userData = { speed: speedRange[0] + Math.random()*(speedRange[1]-speedRange[0]), baseOpacities };
        scene.add(points);
        return points;
    }

    starLayers = [
        createStarField(12000, 120, 0.5, 1.2, [0.5, 0.8]),
        createStarField(10000, 130, 0.8, 1.5, [0.7, 1.0]),
        createStarField(8000, 140, 1.0, 2.0, [0.9, 1.3])
    ];

    renderer = new THREE.WebGPURenderer({ canvas: document.querySelector('#bg-canvas'), antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setAnimationLoop(animate);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    const delta = clock.getDelta();
    if (!forecastRequest) globe.rotation.y += delta * 0.1;
    camera.position.lerp(targetPosition, 0.05);
    camera.lookAt(0,0,0);

    const time = Date.now()*0.001;
    starLayers.forEach((layer,i)=>{
        const base = layer.userData.baseOpacities;
        const avgOpacity = base.reduce((sum,b)=>sum+b*(0.7+0.3*Math.sin(time*layer.userData.speed+Math.random()*Math.PI)),0)/base.length;
        layer.material.opacity = avgOpacity;
    });

    renderer.render(scene,camera);
}

// --- UI ---
const form = document.getElementById('location-form');
const input = document.getElementById('location-input');
const mainUI = document.getElementById('main-ui');
const forecastResult = document.getElementById('forecast-result');
const backButton = document.getElementById('back-button');

const cityCoordinates = {
    'tokio': { lat: 35.6895, lon: 159.6917 },
    'paris': { lat: 48.8566, lon: 22.3522 },
    'londres': { lat: 51.5074, lon: 19.8278 },
    'new york': { lat: 40.7128, lon: -54.0060 },
    'sydney': { lat: -33.8688, lon: 171.2093 },
    'el cairo': { lat: 30.0444, lon: 51.2357 },
    'rio de janeiro': { lat: -22.9068, lon: -23.1729 },
    'mexico': { lat: 19.4326, lon: -79.1332 }
};

form.addEventListener('submit',(e)=>{
    e.preventDefault();
    const query = input.value.toLowerCase().trim();
    if(!query) return;
    const foundCity = Object.keys(cityCoordinates).find(city=>query.includes(city));
    if(foundCity){
        const {lat,lon} = cityCoordinates[foundCity];
        zoomToLocation(lat,lon);
        forecastRequest={city:foundCity,query};
    } else {
        targetPosition.set(0,0,2.5);
        forecastRequest={city:"un lugar desconocido",query};
    }
    mainUI.style.opacity='0';
});

backButton.addEventListener('click',()=>resetView());

function latLonToVector3(lat, lon, radius) {
    // Esta función ya es correcta, solo la incluimos para tener el bloque completo.
    const phi = (90 - lat) * (Math.PI / 180);
    const theta = (lon + 180) * (Math.PI / 180);
    const x = -(radius * Math.sin(phi) * Math.cos(theta));
    const y = radius * Math.cos(phi);
    const z = radius * Math.sin(phi) * Math.sin(theta);
    return new THREE.Vector3(x, y, z);
}

function zoomToLocation(lat, lon) {
    // --- CAMBIOS CLAVE AQUÍ ---
    // 1. Usamos el nuevo radio del globo: 1
    const target3D = latLonToVector3(lat, lon, 1); 

    // 2. Acercamos mucho más la cámara, ya que el globo es más pequeño.
    //    Un valor de 2.5 es bueno (antes era 10). Puedes ajustar este número si quieres.
    const cameraOffset = target3D.clone().normalize().multiplyScalar(2.5);
    
    targetPosition.copy(cameraOffset);
}

function resetView() {
    // --- CAMBIO CLAVE AQUÍ ---
    // 1. La posición de reinicio ahora es 5 (antes era 15).
    targetPosition.set(0, 0, 5);
    mainUI.style.opacity = '1';
    forecastResult.classList.add('hidden');
    forecastRequest = null;
}

function displayForecast(city, query){
    const forecastLocation = document.getElementById('forecast-location');
    const forecastDate = document.getElementById('forecast-date');
    const forecastDetails = document.getElementById('forecast-details');
    const timeMatch = query.match(/en (\d+ \w+)/);
    const dateText = timeMatch ? `Para ${timeMatch[1]}` : 'En un futuro cercano';
    forecastLocation.textContent = city.charAt(0).toUpperCase()+city.slice(1);
    forecastDate.textContent=dateText;
    const temp=(Math.random()*25+5).toFixed(1);
    const precipitation=(Math.random()*100).toFixed(0);
    const wind=(Math.random()*30+5).toFixed(1);
    const summaries=["Se esperan condiciones climáticas estables.","Posibilidad de eventos meteorológicos anómalos.","Tendencia a temperaturas por encima de la media histórica.","Periodos de sequía alternados con lluvias intensas."];
    const summary = summaries[Math.floor(Math.random()*summaries.length)];
    forecastDetails.innerHTML=`
        <div class="space-y-4 text-left">
            <p class="text-lg"><strong>Temperatura Promedio:</strong> ${temp}°C</p>
            <p class="text-lg"><strong>Probabilidad de Precipitación:</strong> ${precipitation}%</p>
            <p class="text-lg"><strong>Viento Promedio:</strong> ${wind} km/h</p>
            <p class="text-lg mt-4"><strong>Resumen:</strong> ${summary}</p>
        </div>
    `;
    forecastResult.classList.remove('hidden');
}

window.addEventListener('resize',onWindowResize);
</script>
</body>
</html>
