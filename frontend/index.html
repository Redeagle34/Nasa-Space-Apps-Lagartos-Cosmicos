<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pronóstico Futurista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Evita barras de scroll por el canvas */
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Coloca el canvas detrás del contenido */
        }
        /* Estilo para el placeholder del input */
        input::placeholder {
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Contenedor para la escena 3D de Three.js -->
    <canvas id="bg-canvas"></canvas>

    <!-- Contenedor principal de la UI -->
    <main class="relative z-10 flex flex-col items-center justify-center h-screen p-4 transition-opacity duration-1000" id="main-ui">
        <div class="text-center w-full max-w-2xl">
            <h1 class="text-4xl md:text-6xl font-bold mb-6 text-shadow-lg">Cuéntame, ¿cuál es tu plan?</h1>
            <p class="text-lg md:text-xl text-gray-300 mb-8">Escribe un lugar y una fecha futura (ej. "París en 3 meses") para obtener un pronóstico especulativo.</p>
            
            <form id="location-form" class="flex flex-col sm:flex-row gap-3">
                <input type="text" id="location-input" placeholder="Ej: Tokio en 6 meses..." class="w-full px-5 py-4 text-lg bg-gray-800 bg-opacity-70 border border-gray-600 rounded-full focus:ring-2 focus:ring-blue-500 focus:outline-none placeholder-gray-500 transition-all duration-300">
                <button type="submit" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-lg font-semibold transition-all duration-300">
                    Visualizar
                </button>
                <label class="flex items-center gap-2 text-sm text-gray-300">
                    <input id="useGemini" type="checkbox" class="w-4 h-4" /> Analizar con Gemini (backend)
                </label>
                <button id="testApiBtn" type="button">Test Backend Connection</button>
                <div id="testApiResult"></div>
            </form>
        </div>
    </main>
    
    <!-- Contenedor para mostrar los resultados del pronóstico -->
    <div id="forecast-result" class="hidden absolute z-20 top-0 left-0 w-full h-full flex items-center justify-center p-4 bg-black bg-opacity-50 backdrop-blur-sm">
        <div class="bg-gray-800 bg-opacity-80 p-8 rounded-2xl shadow-2xl max-w-md w-full border border-gray-700">
            <h2 class="text-3xl font-bold mb-2" id="forecast-location"></h2>
            <p class="text-lg text-blue-300 mb-6" id="forecast-date"></p>
            <div id="forecast-details">
                <!-- El contenido del pronóstico se insertará aquí -->
            </div>
             <p class="text-sm text-gray-400 mt-6 italic">Nota: Este es un pronóstico simulado con fines demostrativos.</p>
            <button id="back-button" class="w-full mt-6 px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-lg font-semibold transition-colors">Volver</button>
        </div>
    </div>

    <script type="module">
        // Importar Three.js desde un CDN
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';

        // --- Configuración básica de la escena ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.querySelector('#bg-canvas'),
            antialias: true 
        });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    // La posición inicial de la cámara se ajustará dinámicamente después de crear el globo

        // Se agrega un color de fondo para mejorar el contraste inicial
        scene.background = new THREE.Color(0x000011);

        // --- Creación del Planeta Tierra (más realista) ---
    const EARTH_RADIUS = 9; // incrementado para un globo más grande
        const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 96, 96);
        const textureLoader = new THREE.TextureLoader();
    const earthColorMap = textureLoader.load('assets/earth_texture.svg');
        const earthBumpMap = textureLoader.load('https://threejs.org/examples/textures/earthbump1k.jpg');
        const earthSpecMap = textureLoader.load('https://threejs.org/examples/textures/earthspec1k.jpg');

        const earthMaterial = new THREE.MeshPhongMaterial({
            map: earthColorMap,
            bumpMap: earthBumpMap,
            bumpScale: 0.05,
            specularMap: earthSpecMap,
            specular: new THREE.Color('grey')
        });

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

    // Posición inicial de la cámara basada en el radio del planeta
    camera.position.set(0, 0, EARTH_RADIUS * 2.5);
    camera.lookAt(0, 0, 0);

        
        // --- Creación del fondo de estrellas ---
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            const dist = Math.sqrt(x*x + y*y + z*z);
            if (dist > 300) starVertices.push(x, y, z); // Solo estrellas lejanas
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

    // --- Iluminación más realista ---
    // Luz ambiental tenue para no perder detalle en sombras
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(ambientLight);

    // HemisphereLight para simular luz difusa del cielo y tierra
    const hemi = new THREE.HemisphereLight(0xbfe1ff, 0x444444, 0.35);
    hemi.position.set(0, 200, 0);
    scene.add(hemi);

    // Directional light como 'Sol' para crear sombras y highlights realistas
    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(100, 40, 100);
    sun.castShadow = false; // no necesitamos sombras de malla para este demo
    scene.add(sun);

    // pequeño punto de relleno para balance de especular
    const fill = new THREE.PointLight(0xffffff, 0.15);
    fill.position.set(-50, -20, -50);
    scene.add(fill);

        // --- Datos de ciudades para simulación de zoom (fallback local) ---
        // Se puede expandir con más ciudades; se usará Nominatim antes que este diccionario.
        const cityCoordinates = {
            'tokio': { lat: 35.6895, lon: 139.6917 },
            'paris': { lat: 48.8566, lon: 2.3522 },
            'londres': { lat: 51.5074, lon: -0.1278 },
            'new york': { lat: 40.7128, lon: -74.0060 },
            'sydney': { lat: -33.8688, lon: 151.2093 },
            'el cairo': { lat: 30.0444, lon: 31.2357 },
            'rio de janeiro': { lat: -22.9068, lon: -43.1729 },
            'mexico': { lat: 19.4326, lon: -99.1332 }
        };

        // --- Animación y Controles ---
        // Usamos quaternions para rotación suave del globo
        let targetRotationQ = new THREE.Quaternion().copy(earth.quaternion);
        let startRotationQ = new THREE.Quaternion().copy(earth.quaternion);
        let rotateT = 1; // t en [0,1] para slerp (1 = sin movimiento)
        // posición de cámara por defecto basada en el radio del planeta
        let targetPosition = new THREE.Vector3(0, 0, EARTH_RADIUS * 2.5);
        let startCameraPos = new THREE.Vector3();
        let cameraT = 1; // serie de t para lerp de la cámara
        let forecastRequest = null; // Para controlar cuándo mostrar el pronóstico

        // Duraciones dinámicas
        let rotateDuration = 2.5; // en segundos (ajustable dinámicamente)
        let cameraDuration = 2.5; // en segundos (ajustable dinámicamente)

        // Velocidad de rotación en reposo (radians/frame aprox.)
        const IDLE_ROTATION_SPEED = 0.0006;

        // Easing usado para suavizar slerp/lerp
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotación suave del planeta usando slerp entre quaternions (duración basada en rotateDuration)
            if (rotateT < 1) {
                // asumimos ~60 FPS para calcular el paso por frame
                rotateT = Math.min(1, rotateT + (1 / (60 * rotateDuration)));
                THREE.Quaternion.slerp(startRotationQ, targetRotationQ, earth.quaternion, easeOutCubic(rotateT));
            } else {
                // Rotación en reposo (suave) cuando no hay una solicitud de pronóstico activa
                if (!forecastRequest) {
                    earth.rotation.y += IDLE_ROTATION_SPEED;
                    // sincronizar quaternions base para futuras slerp
                    earth.quaternion.normalize();
                }
            }

            // Suavizar movimiento de la cámara (duración dinámica)
            if (cameraT < 1) {
                cameraT = Math.min(1, cameraT + (1 / (60 * cameraDuration)));
                // Interpolar desde la posición inicial guardada hacia la targetPosition
                camera.position.lerpVectors(startCameraPos, targetPosition, easeOutCubic(cameraT));
            } else {
                camera.position.lerp(targetPosition, 0.02);
            }
            camera.lookAt(0, 0, 0);

            // Comprobar si el zoom y rotación han terminado para mostrar el pronóstico
            if (forecastRequest && camera.position.distanceTo(targetPosition) < 0.15 && rotateT >= 1) {
                displayForecast(forecastRequest.city, forecastRequest.query);
                forecastRequest = null; // Limpiar la solicitud para que no se ejecute de nuevo
            }

            renderer.render(scene, camera);
        }
        animate();
        
        // --- Lógica de la Interfaz ---
        const form = document.getElementById('location-form');
        const input = document.getElementById('location-input');
        const mainUI = document.getElementById('main-ui');
        const forecastResult = document.getElementById('forecast-result');
        const backButton = document.getElementById('back-button');

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const query = input.value.trim();
            if (!query) return;

            mainUI.style.opacity = '0';

            // Intentar geocodificar con Nominatim (OpenStreetMap)
            let lat, lon, displayName;
            try {
                const nominatimUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;
                const res = await fetch(nominatimUrl, { headers: { 'Accept-Language': 'es' } });
                const data = await res.json();
                if (data && data.length > 0) {
                    lat = parseFloat(data[0].lat);
                    lon = parseFloat(data[0].lon);
                    displayName = data[0].display_name;
                }
            } catch (err) {
                console.warn('Nominatim error', err);
            }

            // Si Nominatim no devolvió resultados, buscar en el diccionario local por palabras clave
            if (lat == null || lon == null) {
                const lower = query.toLowerCase();
                const foundCity = Object.keys(cityCoordinates).find(city => lower.includes(city));
                if (foundCity) {
                    ({ lat, lon } = cityCoordinates[foundCity]);
                    displayName = foundCity;
                }
            }

            if (lat != null && lon != null) {
                // Centrar el globo hacia lat/lon
                rotateEarthTo(lat, lon);
                // Hacer zoom de la cámara (escala con el radio de la Tierra)
                const target3D = latLonToVector3(lat, lon, EARTH_RADIUS);
                const cameraOffset = target3D.clone().normalize().multiplyScalar(EARTH_RADIUS * 2.5);
                startCameraMove(cameraOffset);

                forecastRequest = { city: displayName || query, query };
            } else {
                // Fallback genérico
                startCameraMove(new THREE.Vector3(0, 0, EARTH_RADIUS + 3));
                forecastRequest = { city: 'un lugar desconocido', query };
            }
        });
        
        backButton.addEventListener('click', () => {
            resetView();
        });

        // --- Backend / Gemini integration helpers ---
        async function pingBackend() {
            try {
                const res = await fetch('/api/ping');
                const data = await res.json();
                return data;
            } catch (err) {
                throw err;
            }
        }

        async function analyzeWithBackend(prompt) {
            // POST /api/analyze { prompt }
            const res = await fetch('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt })
            });
            if (!res.ok) throw new Error('Analyze request failed');
            return await res.json(); // expected: { refinedPrompt, location: { lat, lon, name }, extra }
        }

        async function sendToBackend(payload) {
            // POST /api/submit { payload }
            const res = await fetch('/api/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error('Submit request failed');
            return await res.json();
        }

        document.getElementById('testApiBtn').addEventListener('click', async () => {
            const out = document.getElementById('testApiResult');
            out.textContent = 'Pinging backend...';
            try {
                const r = await pingBackend();
                out.textContent = `Backend: ${JSON.stringify(r)}`;
            } catch (err) {
                out.textContent = `Error: ${err.message}`;
            }
        });

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);

            return new THREE.Vector3(x, y, z);
        }

        // Inicia una transición de cámara a la posición objetivo
        function startCameraMove(cameraOffset) {
            // resetear t para lerp
            cameraT = 0;
            // guardar posición inicial de la cámara para la interpolación
            startCameraPos.copy(camera.position);
            // fijar targetPosition a la nueva posición
            targetPosition.copy(cameraOffset);
            // Ajustar duración de la cámara en función de la distancia (más lejos -> más tiempo)
            const dist = startCameraPos.distanceTo(targetPosition);
            cameraDuration = Math.max(1.2, Math.min(6, dist / 3));
        }

        // Rota la Tierra para que (lat,lon) quede frente a la cámara (= en -Z)
        function rotateEarthTo(lat, lon) {
            // Punto en la superficie
            const target = latLonToVector3(lat, lon, EARTH_RADIUS).normalize();

            // Queremos rotar el polo "frontal" (0,0,1) del objeto hacia target
            const currentFront = new THREE.Vector3(0, 0, 1).applyQuaternion(earth.quaternion);
            const axis = new THREE.Vector3().crossVectors(currentFront, target).normalize();
            let angle = Math.acos(THREE.MathUtils.clamp(currentFront.dot(target), -1, 1));
            if (!axis.lengthSq() || isNaN(angle)) {
                // Si ya está alineado, no hacer nada
                return;
            }

            // Crear quaternion objetivo que representa la rotación incremental
            const q = new THREE.Quaternion();
            q.setFromAxisAngle(axis, angle);

            // Guardar quaternions para slerp
            startRotationQ.copy(earth.quaternion);
            targetRotationQ.copy(q.multiply(startRotationQ));
            rotateT = 0;
            // Ajustar duración de la rotación basada en el ángulo (ángulo mayor -> más tiempo)
            // Normalizamos: angle / PI en [0,1], mapeamos a [1.2s, 6s]
            rotateDuration = Math.max(1.2, Math.min(6, (angle / Math.PI) * 5 + 0.8));
        }

        function resetView() {
            targetPosition.set(0, 0, EARTH_RADIUS * 2.5); // Vuelve a la posición inicial basada en el radio
            mainUI.style.opacity = '1';
            forecastResult.classList.add('hidden');
            forecastRequest = null; // Cancelar cualquier solicitud de pronóstico pendiente
            // Restaurar duraciones por defecto para movimientos suaves
            rotateDuration = 2.5;
            cameraDuration = 2.5;
        }
        
        // --- Simulación de API de Pronóstico ---
        function displayForecast(city, query) {
            const forecastLocation = document.getElementById('forecast-location');
            const forecastDate = document.getElementById('forecast-date');
            const forecastDetails = document.getElementById('forecast-details');
            
            // Extraer el tiempo del query si existe
            const timeMatch = query.match(/en (\d+ \w+)/);
            const dateText = timeMatch ? `Para ${timeMatch[1]}` : 'En un futuro cercano';

            forecastLocation.textContent = city.charAt(0).toUpperCase() + city.slice(1);
            forecastDate.textContent = dateText;
            
            // Generar datos falsos
            const temp = (Math.random() * 25 + 5).toFixed(1);
            const precipitation = (Math.random() * 100).toFixed(0);
            const wind = (Math.random() * 30 + 5).toFixed(1);
            const summaries = ["Se esperan condiciones climáticas estables.", "Posibilidad de eventos meteorológicos anómalos.", "Tendencia a temperaturas por encima de la media histórica.", "Periodos de sequía alternados con lluvias intensas."];
            const summary = summaries[Math.floor(Math.random() * summaries.length)];

            forecastDetails.innerHTML = `
                <div class="space-y-4 text-left">
                    <p class="text-lg"><strong>Temperatura Promedio:</strong> ${temp}°C</p>
                    <p class="text-lg"><strong>Probabilidad de Precipitación:</strong> ${precipitation}%</p>
                    <p class="text-lg"><strong>Viento Promedio:</strong> ${wind} km/h</p>
                    <p class="text-lg mt-4"><strong>Resumen:</strong> ${summary}</p>
                </div>
            `;

            // Muestra el resultado inmediatamente (ya no usa setTimeout)
            forecastResult.classList.remove('hidden');
        }
        
        // --- Manejo del redimensionamiento de la ventana ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>

    <script src="script.js"></script>
</body>
</html>

